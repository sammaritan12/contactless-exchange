"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class SelectService {
    constructor(options = {}) {
        this.select = (option, selectedOptions) => {
            return this.strategy.select(option, selectedOptions);
        };
        this.isSelected = (option, options) => {
            return this.strategy.isSelected(option, options);
        };
        this.toStringOptions = (options) => {
            return options && this.strategy.toStringOptions(options);
        };
        const { multiSelect, keyExtractor } = options;
        this.strategy = multiSelect ? new MultiSelectStrategy(keyExtractor) : new SingleSelectStrategy(keyExtractor);
    }
}
exports.SelectService = SelectService;
SelectService.isGroup = (option) => {
    return option.items && option.items.length > 0;
};
SelectService.toStringOption = (option) => {
    return option.text;
};
SelectService.isEqualOptions = (lhs, rhs, keyExtractor) => {
    if (keyExtractor) {
        return (lhs && rhs) && keyExtractor(lhs) === keyExtractor(rhs);
    }
    return lhs === rhs;
};
class SingleSelectStrategy {
    constructor(keyExtractor) {
        this.keyExtractor = keyExtractor;
        this.select = (option) => {
            return option;
        };
        this.isSelected = (option, selectedOption) => {
            if (SelectService.isGroup(option)) {
                return option.items.some(groupOption => this.isSelected(groupOption, selectedOption));
            }
            return SelectService.isEqualOptions(selectedOption, option, this.keyExtractor);
        };
        this.toStringOptions = (option) => {
            return SelectService.toStringOption(option);
        };
    }
}
class MultiSelectStrategy {
    constructor(keyExtractor) {
        this.keyExtractor = keyExtractor;
        this.select = (option, selectedOptions = []) => {
            if (SelectService.isGroup(option)) {
                return this.selectOptionGroup(option, selectedOptions);
            }
            else {
                return this.selectOption(option, selectedOptions);
            }
        };
        this.isSelected = (option, selectedOptions = []) => {
            return this.isOptionSelected(option, selectedOptions);
        };
        this.toStringOptions = (options = []) => {
            return options.map(SelectService.toStringOption).join(', ');
        };
        this.selectOptionGroup = (option, selectedOptions) => {
            if (this.isGroupSelected(option, selectedOptions)) {
                return this.removeOptionGroup(option, selectedOptions);
            }
            else {
                return this.addOptionGroup(option, selectedOptions);
            }
        };
        this.selectOption = (option, selectedOptions) => {
            if (this.isOptionSelected(option, selectedOptions)) {
                return this.removeOption(selectedOptions, option);
            }
            else {
                return this.addOption(option, selectedOptions);
            }
        };
        this.isGroupSelected = (group, selectedOptions) => {
            return selectedOptions.some((selectedOption) => {
                return this.isOptionSelected(selectedOption, group.items);
            });
        };
        this.isOptionSelected = (option, selectedOptions) => {
            return selectedOptions.some((selectedOption) => {
                return SelectService.isEqualOptions(selectedOption, option, this.keyExtractor);
            });
        };
        this.addOptionGroup = (option, selectedOptions) => {
            const options = option.items.filter(groupOption => !groupOption.disabled);
            return selectedOptions.concat(options);
        };
        this.addOption = (option, selectedOptions) => {
            return selectedOptions.concat(option);
        };
        this.removeOptionGroup = (option, selectedOptions) => {
            return option.items.reduce(this.removeOption, selectedOptions);
        };
        this.removeOption = (selectedOptions, option) => {
            return selectedOptions.filter((selectedOption) => {
                return !SelectService.isEqualOptions(selectedOption, option, this.keyExtractor);
            });
        };
    }
}
//# sourceMappingURL=select.service.js.map
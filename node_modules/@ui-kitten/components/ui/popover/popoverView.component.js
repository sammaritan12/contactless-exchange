"use strict";
/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const react_native_1 = require("react-native");
const theme_1 = require("../../theme");
const type_1 = require("./type");
const services_1 = require("../support/services");
const INDICATOR_OFFSET = 8;
const INDICATOR_WIDTH = 6;
class PopoverViewComponent extends react_1.default.Component {
    constructor() {
        super(...arguments);
        this.getComponentStyle = (source) => {
            const { indicatorWidth, indicatorHeight, indicatorBackgroundColor, ...containerParameters } = source;
            return {
                content: containerParameters,
                indicator: {
                    width: indicatorWidth,
                    height: indicatorHeight,
                    backgroundColor: indicatorBackgroundColor,
                },
            };
        };
        this.getDirectionStyle = () => {
            const { direction, alignment } = this.placement.flex();
            const isVertical = direction.startsWith('column');
            const isStart = alignment.endsWith('start');
            const isEnd = alignment.endsWith('end');
            const isReverse = direction.endsWith('reverse');
            // Rotate indicator by 90 deg if we have `row` direction (left/right placement)
            // Rotate it again by 180 if we have `row-reverse` (bottom/right placement)
            const indicatorRotate = isVertical ? 180 : 90;
            const indicatorReverseRotate = isReverse ? 0 : 180;
            // Translate container by half of `indicatorWidth`. Exactly half (because it has a square shape)
            // Reverse if needed
            // @ts-ignore: indicatorWidth type is always number
            let containerTranslate = (this.props.indicator && !isVertical) ? INDICATOR_WIDTH / 2 : 0;
            containerTranslate = isReverse ? containerTranslate : -containerTranslate;
            // Translate indicator by passed `indicatorOffset`
            // Reverse if needed
            let indicatorTranslate = isVertical ? -INDICATOR_OFFSET : INDICATOR_OFFSET;
            indicatorTranslate = isReverse ? -indicatorTranslate : indicatorTranslate;
            const i18nVerticalIndicatorTranslate = services_1.I18nLayoutService.select(indicatorTranslate, -indicatorTranslate);
            indicatorTranslate = isVertical ? i18nVerticalIndicatorTranslate : indicatorTranslate;
            const contentTransforms = {
                transform: [
                    { translateX: containerTranslate },
                ],
            };
            const indicatorTransforms = {
                transform: [
                    { rotate: `${indicatorRotate}deg` },
                    { rotate: `${indicatorReverseRotate}deg` },
                    // Translate indicator "to start" if we have `-start` alignment
                    // Or translate it "to end" if we have `-end` alignment
                    { translateX: isStart ? -indicatorTranslate : 0 },
                    { translateX: isEnd ? indicatorTranslate : 0 },
                ],
            };
            return {
                container: {
                    flexDirection: direction,
                    alignItems: alignment,
                },
                content: contentTransforms,
                indicator: indicatorTransforms,
            };
        };
        this.renderIndicatorElement = (style, directionStyle) => {
            const indicatorElement = this.props.indicator(style);
            return react_1.default.cloneElement(indicatorElement, {
                style: [style, directionStyle, indicatorElement.props.style],
            });
        };
        this.renderComponentChildren = (style, directionStyle) => {
            return [
                this.props.indicator && this.renderIndicatorElement(style.indicator, directionStyle.indicator),
            ];
        };
    }
    get placement() {
        return type_1.PopoverPlacements.parse(this.props.placement);
    }
    render() {
        const { style, contentContainerStyle, themedStyle, onLayout, ...props } = this.props;
        const { content, ...componentStyle } = this.getComponentStyle(themedStyle);
        const directionStyle = this.getDirectionStyle();
        const [indicatorElement] = this.renderComponentChildren(componentStyle, directionStyle);
        return (react_1.default.createElement(react_native_1.View, { style: [directionStyle.container, contentContainerStyle], onLayout: onLayout },
            indicatorElement,
            react_1.default.createElement(react_native_1.View, Object.assign({}, props, { style: [content, directionStyle.content, style] }))));
    }
}
PopoverViewComponent.styledComponentName = 'Popover';
exports.PopoverView = theme_1.styled(PopoverViewComponent);
//# sourceMappingURL=popoverView.component.js.map